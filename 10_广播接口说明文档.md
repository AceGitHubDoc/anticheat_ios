## 功能介绍

SDK为高级VIP用户提供反外挂检测接口功能，将检测到的用户作弊信息以实时广播的形式同步给游戏侧。游戏项目组可以根据检测结果，自行处理制定作弊打击策略，实现反外挂的自由可控与高度定制化。

**特别说明**

```txt
1、关于SDK版本： SDK4.2及以上版本开始支持该功能；
2、支持的开发语言： SDK提供C#、C++两种形式的接口，开发者可任选一种语言来完成接入；
3、SDK接入： 在阅读本文之前，确保已经正确接入了其他SDK接口；
4. 建议将广播数据传到服务器端，然后由服务器端结合玩家举报、战绩、投诉等指标进行策略准确性
   评估后做出运营决策，切不可将广播数据直接作为唯一处罚依据。
5. 涉及到游戏如何自定义策略，建议咨询客服获取白皮书。
6. 后续实时反外挂的扫描结果也会以广播id = 13的形式同步给游戏侧。
```

## 接口说明

【C++版本】

接口源码文件tp2_sdk.h

```c++
// 信息类型

enum TssInfoType{

    TSS_INFO_TYPE_DETECT_RESULT = 1, // 检测结果

    TSS_INFO_TYPE_HEARTBEAT = 2, // 心跳信息

};

// 开发者需要自己继承类TssInfoReceiver 实现onReceive函数
class TssInfoReceiver{

    public:
    virtual ~TssInfoReceiver(){}

    virtual int getInterfaceVersionCode(){return 1;}

    virtual void onReceive(int tssInfoType,const char* info) = 0;
};

// ...

// 使用此接口注册自己实现的TssInfoReceiver
void tp2_regist_tss_info_receiver(TssInfoReceiver* receiver);

// 将收到的信息使用该接口解密
int tp2_dec_tss_info(const char* src,char* out,size_t len);
```

【C#版本】

c# 接口文件tp2.cs

```csharp

namespace tss{

    // 开发者实现TssInfoReceiver接口
    public interface TssInfoReceiver{

        void onReceive(int tssInfoType,string info);

    }

    public class TssInfoPublisher{
        // 检测结果
        public const int TSS_INFO_TYPE_DETECT_RESULT = 1;
        // 心跳
        public const int TSS_INFO_TYPE_HEARTBEAT = 2;

        // ...

    }
}


public static class Tp2Sdk{
    // ...

    // 使用Tp2RegistTssInfoReceiver注册开发者实现的TssInfoReceiver接口

    public static void Tp2RegistTssInfoReceiver(tss.TssInfoReceiver receiver){

        tss.TssInfoPublisher.getInstance ().registTssInfoReceiver (receiver);

    }


    // 将收到的信息使用该接口解密
    public static string Tp2DecTssInfo(string info){

        string cmd = String.Format("dec_tss_info:{0}",info);

        return Tp2Ioctl(cmd);
    }
// ...
}

```

## 反外挂检测数据格式

**TSS_INFO_TYPE_DETECT_RESULT**

```c++
enum TP2GameStatus{
    TSS_INFO_TYPE_DETECT_RESULT_ANO = 1,
    TSS_INFO_TYPE_DETECT_RESULT_APPFORBID = 2,
    TSS_INFO_TYPE_DETECT_RESULT_GP4 = 3,
    TSS_INFO_TYPE_DETECT_RESULT_GP3 = 4,
    TSS_INFO_TYPE_DETECT_RESULT_VP2 = 5,
    TSS_INFO_TYPE_DETECT_RESULT_VP3 = 6,
    TSS_INFO_TYPE_DETECT_RESULT_TS2 = 7,
    TSS_INFO_TYPE_DETECT_RESULT_EMULATOR = 8,
    TSS_INFO_TYPE_DETECT_RESULT_FORTEST = 9,
    TSS_INFO_TYPE_DETECT_COMMON_INFO = 10,
    TSS_INFO_TYPE_DETECT_SO_REPLACED = 11,
    TSS_INFO_TYPE_DETECT_SUSPICIOUS_APK = 12,
    TSS_INFO_TYPE_DETECT_LUA_REPORT = 13,
    TSS_INFO_TYPE_DETECT_CHECK_HOST = 14,
    TSS_INFO_TYPE_DETECT_CHECK_PERMISSION = 15,
    TSS_INFO_TYPE_DETECT_MALWARES = 16,
    TSS_INFO_TYPE_SUS_MODULE = 17,
    TSS_INFO_TYPE_DETECT_SHELL_STR = 18,
    TSS_INFO_TYPE_DETECT_RESULT_CLOUDPHONE = 19,
    TSS_INFO_TYPE_DETECT_RESULT_LIVE = 20,
    TSS_INFO_TYPE_DETECT_CRACK_CERT = 21,
}
```

```xml
1、接收的所有信息都是一个字符串，字符串格式:"id=value|key=value|key=value|..."。
2、每个字符串至少包含一个名为id的key，用于区分是哪种检测结果。
3、为了保证代码对新版SDK的兼容性，
每个字符串应该采用key=value字典形式解析，不要假设键值对的顺序是不变的，
在新版本的SDK上可能会新增新的广播id，或者在现有广播中以任意的顺序插入新增的键值对。
4. 检测频率：大部分扫描相关的数据是每5min产生一次。
```

**目前支持12种类型检测结果信息**

* id=1 二选一功能

```xml
格式：id=1|name=外挂包名|...
    name：比如name=catch_.me_.if_.you_.can_
    feature=外挂唯一标识，例如：VP_开头的特征对应的是虚拟机类型外挂
备注：只要收到该信息，可确认玩家设备上安装了已知外挂样本
```

* id=3 修改器检测

```xml
格式：id=3|reason=检测到内存访问原因|root=手机是否root
    reason：可能是修改器的包名，可能是主动防御系统失效等
        reason=604: 对应可疑修改器检测,表示只检测到了修改行为
        reason=其他：可能是进程名，也可能是修改器包名
    root=1表示手机已root，root=0表示手机未root
备注：只要收到该信息，可确认游戏内存被读写
```

* id=7 变速器检测

```xml
格式：id=7|rate=变速倍数|reason=原因
    rate：变速倍数/100 后才是真实的倍率。
    如rate=100变速未变速，rate=150表示加速，倍率为1.5，rate=80变速减速，倍率为0.8。
    reason：可能是变速器进程名，可能是变速器模块名，可能是时间函数被hook
        reason=none：对应可疑变速器检测，即只检测到变速，未检测到变速器的特征（如进程、模块等）
        reason=hook：时间函数被hook
        reason=其他：可能是进程名，可能是模块名
备注：只要收到该信息，可确认游戏变速异常
```

* id=9 测试用广播

```xml
格式：id=9|info=foo
备注：此广播在 SDK 启动后 30-60s 内必定触发 1-2 次，用于测试用，不存在周期性且不代表任何恶意检测结果
```

* id=10 通用环境信息广播

```xml
格式：id=10|jailbreak=|...
    jailbreak=1表示手机越狱，jailbreak=0表示手机未越狱
    jb_record=1表示手机曾经越狱，jb_record=0表示手机未曾越狱过
    cert_md5=应用证书md5，用于辅助检测破解版，正常用户的证书md5都是一样的，非正常用户各有各同
    cert_author=应用证书作者
    v1=app版本号
    v2=app short版本号
    mem_encrypt_flag=内存加密位
    file_encrypt_flag=文件加密位
备注：用于辅助策略制定，不管什么情况下都会上报，无论是正常用户还是非正常用户
```

* id=13 特征数据上报

```xml
格式：id=13|...
备注：该广播为实时反外挂模块主动推送的广播，具体格式与含义见所本平台订阅的实时反外挂描述信息。
```

* id=14 域名检测

```xml
格式：id=14|host=被屏蔽的域名
备注：只要接收到该消息，说明检测到通过host文件屏蔽SDK数据通道域名
```

* id=15 缓存目录权限检测

```xml
格式：id=15|path=存在权限异常的文件|permission=权限异常种类
备注：只要接收到该消息，说明检测到缓存目录权限被修改
```

* id=16 可疑的作弊软件检测

```xml
格式：id=16|app_name=作弊软件名
    app_name：比如app_name=iGameGuardian.app
备注：可用量的聚集辅助策略制定
```

* id=17 可疑注入模块检测

```xml
格式：id=17|name=|...
    name=可疑的模块名称
    size=可疑模块大小
    crc=可疑模块crc
    ext_info=额外的信息，例如模块的最后修改时间
备注：只要收到该消息，说明检测到可疑的模块注入
```

* id=18 同步壳的信息

```xml
格式：id=18|shell_ver=|...
    shell_ver=壳版本
    apk_path=壳获取到的apk路径，用于辅助检测破解版
备注：用于同步壳获取到的apk路径
```

* id=21 同步可疑证书检测的信息

```xml
格式：id=21|cert=|author=
    cert=应用证书md5，用于辅助检测破解版，正常用户的证书md5都是一样的，非正常用户各有各同
    author=应用证书作者
备注: 只要收到该消息,说明检测到符合闪退条件的证书信息
```

## 防剥离心跳数据格式

**TSS_INFO_TYPE_HEARTBEAT**

```xml
1、接收的所有信息都是一个字符串，字符串格式："id=value|key=value|key_value|..."
2、每个字符串至少包含一个名为id的key，用于区分是哪种心跳信息
3、目前只有一种类型id=1，用于游戏自己检测SDK的运行状态。
```

```xml
• 格式：id=1|seq=序列号|pid=进程ID|time=手机开机启动时间
    • seq=序列号 序列号从1开始，递增
    • pid=游戏进程id 每次收到的pid应该一致
    • time=手机开机启动时间 采用clock_gettime(CLOCK_MONOTONIC,...)获取。
• 心跳频率：每10s中发送一次数据
• 使用方法：可以通过检查每次收到的数据seq是否递增，pid是否相同来判断SDK状态是否正常
```

## 演示代码

【C++版本】

```c++
// TssInfoReceiver接口实现
class MyTssInfoReceiver:public TssInfoReceiver{

    public:
    virtual void onReceive(int tssInfoType,const char* info){

    char plain[256];
    memset(plain,0x00,sizeof(plain));
    // 将plain字符串数据上传到服务器端，由游戏进行自定义策略
    if (tssInfoType == TSS_INFO_TYPE_DETECT_RESULT){

        // 只关注TSS_INFO_TYPE_DETECT_RESULT
        int ret =tp2_dec_tss_info(info,plain,sizeof(plain));
        if (ret == -1) return;
            __android_log_print(ANDROID_LOG_DEBUG,"SDK",
            "[C++ Cheat Info]:%d|%s", tssInfoType,plain);
    }else if (tssInfoType == TSS_INFO_TYPE_HEARTBEAT){

        // // 处理心跳，如果不关心，可以忽略
        int ret =tp2_dec_tss_info(info,plain,sizeof(plain));
        if (ret == -1) return;
        __android_log_print(ANDROID_LOG_DEBUG,"SDK",
        "[C++ Cheat Info]:%d|%s", tssInfoType,plain);}
    }
};

MyTssInfoReceiver g_tss_info_receiver;

void game_start() {
    // 游戏启动的第一时间调用 先于tp2_sdk_init_ex
    tp2_regist_tss_info_receiver(&g_tss_info_receiver);
    tp2_sdk_init_ex (9000, "d5ab8dc7ef67ca92e41d730982c5c602");

    // 用户登录时调用
    int account_type = ENTRY_ID_QZONE; /*帐号类型*/
    int world_id = 101; /*大区id*/
    char open_id[] = "B73B36366565F9E02C752"; /*与平台相关的用户标识*/
    char role_id[] = "paladin"; /*角色id*/
    tp2_setuserinfo(account_type, world_id, open_id, role_id);
}
```

【C#版本】

```csharp
public class main : MonoBehaviour {

    // TssInfoReceiver接口实现
    private class MyTssInfoReceiver:tss.TssInfoReceiver{

        // 将plain字符串数据上传到服务器端，由游戏进行自定义策略
        public void onReceive(int tssInfoType, string info){

            // 此函数不能被阻塞
            if (tssInfoType == tss.TssInfoPublisher.TSS_INFO_TYPE_DETECT_RESULT) {

                // 处理检测结果 如果不关心，可以忽略
                string plain = Tp2Sdk.Tp2DecTssInfo(info);
                if (plain.Equals("-1")) return;
                Debug.Log ("C# Info:" + tssInfoType + "|" + plain);
            }else if (tssInfoType == tss.TssInfoPublisher.TSS_INFO_TYPE_HEARTBEAT){

                // 处理心跳，如果不关心，可以忽略
                string plain = Tp2Sdk.Tp2DecTssInfo(info);
                if (plain.Equals("-1")) return;
                Debug.Log ("C# Info:" + tssInfoType + "|" + plain);
            }
        }
    }

    private MyTssInfoReceiver mTssInfoReceiver;

    void Awake () {
        // 在游戏启动的第一时间调用 时机先于Tp2SdkInitEx接口
        mTssInfoReceiver = new MyTssInfoReceiver();
        Tp2Sdk.Tp2RegistTssInfoReceiver (mTssInfoReceiver);
        Tp2Sdk.Tp2SdkInitEx(9000, "d5ab8dc7ef67ca92e41d730982c5c602");
        Debug.Log ("C#:main::Awake");
    }
// ...
}
```
