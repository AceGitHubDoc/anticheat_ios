本文档说明SDK安全数据接入步骤，假设游戏项目组已根据《C#接入教程》、《Android C版接入教程》完成了SDK其它接口的接入。根据接入的安全SDK选择对应的步骤接入

**特别说明**

```xml
1、关于SDK版本： SDK3.8.9及以上版本开始支持该功能；
2、支持的开发语言： SDK提供C#、C++两种形式的接口，开发者可任选一种语言来完成接入；
3、SDK接入： 在阅读本文之前，确保已经正确接入了其他SDK接口；
4、建议每隔3分钟获取安全SDK核心数据上报服务器，根据多次获取到的数据进行分析、对比，
并结合检测广播接口的数据做自定义策略。
```

## 安全需求

当前存在安全SDK被剥离，不能使用SDK上报数据进行处罚的问题，为更好地保证游戏的安全性，游戏需要在合适时机调用获取安全SDK的核心数据接口获取SDK的核心初始化数据，并将获取到的数据通过一定的方式托传给服务端进行分析。

## C#版

**SDK接口调用条件**

确认引用了SDK的tp2.cs文件

**SDK接口调用**

**函数原型**

```csharp
/**
返回值null，则说明调用失败，请确认cmd参数填写是否正确及SDK版本是否正确；
返回值非null，则返回的字符串即为当前的安全数据，其中字符串长度不会超过128个字节；
*/
string Tp2Ioctl(string cmd);
```

**参数说明**

参数 | 说明
-----|----
cmd | 请求命令,请填写"GetSdkAntiData"

**接口调用**

```csharp
string GetSdkAntiData(){
    return Tp2Sdk.Tp2Ioctl("GetSdkAntiData");
}
```

**调用时机**

建议游戏每隔3分钟调用一次，然后将返回的字符串数据发送给后台，后台接入下文的数据分析代码，通过上报数据判断当前SDK是否有问题

**注意事项**

取到数据后，请勿在同一个线程中进行数据发送（尤其是主线程）。一般采用拷贝数据，放入网络数据发送队列，然后异步发送。

## Android C版

**SDK接口调用条件**

确认引用了SDK的tp2_sdk.h文件

**SDK接口调用**

**函数原型**

```cpp
/**
获取TssSDK需要通过游戏托传到TssSvrSDK的数据
*/
uintptr_t __attribute__((visibility("default"))) tss_get_report_data2();
```

**接口调用**

```cpp
void GetSdkCoreData(){
    struct TssSdkAntiDataInfo *anti_data =
    (struct TssSdkAntiDataInfo *anti_data)tss_get_report_data2();
    if(anti_data != NULL && anti_data->anti_data_len_<= 128){
        /**
        *说明：
        *1、 SDK保证该游戏获取到的核心数据长度不会大于128字节(数据不包含'\0')，
             如果大于128字节游戏可以丢弃；
        *2、anti_data->anti_data_的长度为anti_data->anti_data_len_；
        *3、anti_data->anti_data_为字符串，不会有以'\0'开头的数据，
            可以直接按照字符串的形式进行托传。
        */
    }
}
```

**调用时机**

建议游戏每隔3分钟调用一次，然后将anti_data->anti_data_、anti_data->anti_data_len_
数据发送给后台，后台接入下文的数据分析代码，通过上报数据判断当前SDK是否有问题

**注意事项**

取到数据后，请勿在同一个线程中进行数据发送（尤其是主线程）。一般采用拷贝数据，放入网络数据发送队列，然后异步发送。

## 数据解析

服务器后台收到数据之后，以源码方式接入<a href="/docs/ACE-files/10/30/tss_data_decrypt2.h" download="tss_data_decrypt2.h">tss_data_decrypt2.h</a>、<a href="/docs/ACE-files/10/30/tss_data_decrypt2.cpp" download="tss_data_decrypt2.cpp">tss_data_decrypt2.cpp</a>、<a href="/docs/ACE-files/10/30/crc32.h" download="crc32.h">crc32.h</a>、<a href="/docs/ACE-files/10/30/crc32.c" download="crc32.c">crc32.c</a>这四个文件(服务端为C#则接入<a href="/docs/ACE-files/10/30/tss_data_decrypt2.cs" download="tss_data_decrypt2.cs">tss_data_decrypt2.cs</a>文件)，服务器收到本地传递过来的数据之后，调用tss_data_descrypt2接口进行解析

**函数原型**

```c
c:
int tss_data_descrypt2(const char *buf, size_t buf_len,
struct TssSdkAntiData2* anti_data);
```

```csharp
c#:
Using TssSdk;
bool AntiData2Parser.tss_data_descrypt2(byte[] buf, int buf_len,
out TssSdkAntiData2 anti_data);
```

若服务端为C#，则使用如下代码将string类型的sdk_anti_data数据转换成buf,buf_len

```csharp
String input = sdk_anti_data;
System.Text.Encoding enc = System.Text.Encoding.ASCII;
byte[] buf = enc.GetBytes(input);
int buf_len = buf.Length;
```

得到的anti_data.state_word1中每一位表示SDK客户端一个功能的运行状态或者检测结果。所以游戏后台可以根据这个状态字段来做策略，遇到外挂剥离SDK客户端的情况,可以查看游戏上报的状态字段，如果有出现与正常玩家不一样的结果数据，则可认为对应的SDK功能被剥离或运行异常了，并使用对应的状态数据制定检测策略。

## 举例说明

现有一个虚拟机类型外挂Lulubox，会将安全SDK通过CDN下载特征的渠道和调度线程阻塞，那么就会发现anti_data.state_word1中的三个状态位为0，而且为了避免调用get_report_data2太早导致SDK还未初始化的情况，我们取get_cnt>=2,以保证SDK至少已经启动了3分钟。如下所示：

状态 | 说明 | 值
----|----- | -----
AntiDataMagicFlag2_UpdateCDNRunned | 特征更新是否运行过 | 0
AntiDataMagicFlag2_ScheduleEngIsRunnig | 调度引擎是否正在运行 | 0
AntiDataMagicFlag2_CommDatDownloaded | SDK通用特征comm.dat是否下载成功 | 0

游戏后台就可以通过下面的条件来判断哪些用户使用了此外挂。

```csharp
((anti_data.state_word1 & AntiDataMagicFlag2_UpdateCDNRunned == 0) &&
(anti_data.state_word1 & AntiDataMagicFlag2_ScheduleEnglsRunning == 0) &&
(anti_data.state_word1 & AntiDataMagicFlag2_CommDatDownloaded == 0) &&
anti_data.get_cnt >= 2)
```
